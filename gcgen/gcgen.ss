;; Copyright (C) 2006 Adam C. Wick
;; See LICENSE for licensing information.
;;
;; gcgen.ss: This generates flags and tuning info for the collector.
;;
;; This is pretty straightforward. The only complicated thing is actually a
;; bit of a hack. In order to remove as much duplication as possible, this
;; pass goes through the information generated by the structanalysis phase
;; and removes duplicate entries in different files. This is actually a slight
;; bug, but whatever. (FIXME?)
;;
;; REQUIRES:
;;   contract.ss [mzlib]
;;   list.ss [mzlib]
;;   file.ss [mzlib]
;;   info.ss [../common]
;;   structs.ss [../common]
;;   md5.ss [../common]
;;   add_alloc_notes [../compiler]
;;
;; PROVIDES:
;;   generate-collector-info: -> void
;;   use-null-collector: parameter(bool)
;;   init-nursery-size: parameter(number)
;;   gen0-grow-factor: parameter(number)
;;   gen0-grow-addition: parameter(number)
;;   page-size: parameter(number)
;;   align-to-quadwords: parameter(bool)
;;
(module gcgen mzscheme
  (require (lib "contract.ss" "mzlib")
	   (lib "list.ss" "mzlib")
	   (lib "file.ss" "mzlib")
	   (prefix info: (lib "info.ss" "cconv" "common"))
	   (lib "structs.ss" "cconv" "common")
	   (lib "md5.ss" "cconv" "common")
	   (lib "misc.ss" "cconv" "common"))
  (require-for-syntax (lib "file.ss" "mzlib"))
  (provide/contract
   [generate-collector-info ((union string? path?) . -> . any/c)]
   [make-init-fun-namestr (string? . -> . string?)])
  (provide use-null-collector?
	   init-nursery-size
	   gen0-grow-factor
	   gen0-grow-addition
	   page-size
	   align-to-quadwords)

  ;; This, my friends, is a bit of a hack.
  (define-syntax (__this-dir stx)
    (syntax-case stx ()
      [(_) #`#,(path->string (path-only (syntax-source stx)))]))
  (define this-dir (__this-dir)) ;; path

  
  (define use-null-collector?
    (make-parameter #f
      (lambda (x)
	(unless (boolean? x)
	  (raise-type-error 'use-null-collector? "bool" x))
	x)))

  ;; init-nursery-size: parameter(number)
  (define init-nursery-size
    (make-parameter 2
      (lambda (x)
	(unless (number? x)
	  (raise-type-error 'init-nursery-size "number" x))
	x)))

  ;; gen0-grow-factor: parameter(number)
  (define gen0-grow-factor
    (make-parameter 0.5
      (lambda (x)
	(unless (number? x)
	  (raise-type-error 'gen0-grow-factor "number" x))
	x)))

  ;; gen0-grow-addition: parameter(number)
  (define gen0-grow-addition
    (make-parameter 0.5
      (lambda (x)
	(unless (number? x)
	  (raise-type-error 'gen0-grow-addition "number" x))
	x)))

  ;; page-size: parameter(number)
  (define page-size
    (make-parameter 16
      (lambda (x)
	(unless (and (number? x) (zero? (modulo x 4)))
	  (raise-type-error 'page-size "number divisible by 4" x))
	x)))

  ;; align-to-quadwords: parameter(bool)
  (define align-to-quadwords
    (make-parameter #f
      (lambda (x)
	(unless (boolean? x)
	  (raise-type-error 'align-to-quadwords "boolean" x))
	x)))

  ;; make-init-fun-namestr: str -> str
  ;; Generates the name of an initialization function from a file name
  (define (make-init-fun-namestr filestr)
    (format "__gcINIT_TAGS_~a" (md5 filestr)))

  ;; pull-initialization-functions: -> list(str)
  ;; Returns a list of strings, which are the names of the tag initialization
  ;; functions exported by the files of this system.
  (define (pull-initialization-functions)
    (let ([alloc-files (info:lookup-item 'alloc-analysis-files)])
      (map make-init-fun-namestr alloc-files)))

  ;; get/assign-all-tags: -> list(sym)
  ;; Returns a list of all the tags in the system.
  (define (get/assign-all-tags)
    (let* ([files (info:lookup-item 'alloc-analysis-files)]
	   [satags (hash-table-map (info:lookup-item 'structure-assignments)
				   (lambda (k v) 
				     (name-name (type->tag-name k))))])
      ;; That just gets us the tags for the structure analysis. We also
      ;; need to worry about the tags generated by the allocation analysis,
      ;; by tarray allocations.
      (foldl (lambda (x acc)
	       (let* ([aatags (hash-table-map 
			       (info:lookup-item x 'alloc-analysis)
			       (lambda (_ v)
				 (cond
				  [(eq? (car v) 'tarray)
				   (let ([newts (string-append "tarray "
							       (cadr v))])
				     (list (name-name (type->tag-name newts))))]
				  [else '()])))]
		      [aatags (apply append aatags)])
		 (foldl (lambda (tag acc)
			  (if (member tag acc) acc
			      (cons tag acc)))
			acc aatags)))
	     satags files)))

  ;; page-bits: -> number
  ;; Gets the size of the page in bits.
  (define (page-bits)
    ;; PLT doesn't have a log_2. *sigh*
    (let loop ([val (* (page-size) 1024)] [i 0])
      (cond
       [(= val 1) i]
       [else (loop (/ val 2) (add1 i))])))

  (define (*1MB num)
    (format "(~a * 1024 * 1024)" num))

  ;; dump-setting: output-port str alpha -> void
  ;; Dump a setting to the output port
  (define (dump-setting oport str val)
    (fprintf oport "#define ~a ~a~n" str val))

  ;; generate-collector-info: str -> void
  ;; Generates the information about the collector for the collector. This
  ;; is not a very advanced way of doing this. But that's OK, this doesn't
  ;; require a lot of advanced stuff.
  (define (generate-collector-info odir)
    (let* ([ofile (build-path odir "gc_tuning.h")]
	   [oport (open-output-file ofile 'truncate/replace)]
	   [init-functions (pull-initialization-functions)]
	   [tags (get/assign-all-tags)])
      ;; First, copy the interface and implementation files over to the new
      ;; directory
      (let ([interface.h (if (use-null-collector?)
			     "null_gc_interface.h"
			     "gc_interface.h")]
	    [implementation.c (if (use-null-collector?)
				  "null_gc_implementation.c"
				  "gc_implementation.c")]
	    [is-vm-file? (lambda (x)
			   (let ([name (file-name-from-path x)])
			     (and name
				  (let ([n (path->string name)])
				    (and (regexp-match "^vm_" n)
					 (regexp-match ".c$" n))))))]
	    [copy-file (lambda (x)
			 (let ([from (if (pair? x)
					 (build-path this-dir (car x))
					 (build-path this-dir x))]
			       [to (if (pair? x)
				       (build-path odir (cdr x))
				       (build-path odir x))])
			   (when (file-exists? to)
			     (delete-file to))
			   (make-file-or-directory-link from to)))])
; FIXME			   (copy-file from to)))])
	(map copy-file
	     (append `((,interface.h . "gc_interface.h")
		       (,implementation.c . "gc_implementation.c"))
		     (map file-name-from-path
			  (find-files is-vm-file? this-dir)))))
      ;; Then build the tuning file.
      (fprintf oport "/* THIS FILE IS AUTOMATICALLY GENERATED */~n")
      (fprintf oport "/* DON'T MODIFY IT DIRECTLY             */~n")
      (fprintf oport "/* (unless you know what you're doing)  */~n~n")
      (dump-setting oport "INIT_NURSERY_SIZE" (*1MB (init-nursery-size)))
      (dump-setting oport "GEN0_GROW_FACTOR" (gen0-grow-factor))
      (dump-setting oport "GEN0_GROW_ADDITION" (*1MB (gen0-grow-addition)))
      (dump-setting oport "LOG_PAGE_SIZE" (page-bits)) 
      (when (align-to-quadwords)
	(dump-setting oport "ALIGN_TO_QUADWORDS" "1"))
      (fprintf oport "\n")
      (for-each (lambda (tag)
		  (fprintf oport "gc_tag ~a;~n" tag))
		tags)
      (fprintf oport "\n")
      (for-each (lambda (ifun)
		  (fprintf oport "extern void ~a(void);~n" ifun))
		init-functions)
      (fprintf oport "\n")
      (fprintf oport "static void init_collector(void);~n")
      (fprintf oport "\n")
      (fprintf oport "void initialize_tags(void)\n")
      (fprintf oport "{\n")
      (for-each (lambda (ifun)
		  (fprintf oport "  ~a();\n" ifun))
		init-functions)
      (fprintf oport "}\n")
      (close-output-port oport)))
      

  )
  